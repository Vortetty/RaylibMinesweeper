//
// Autogenerated single header file for rayscenes
// Licensed under the Apache License, Version 2.0
// See the LICENSE file in the project root for more information
// Â© Winter/Vortetty 2021 
//

#ifndef RAYSCENES_HEADER_ALREADY_DONE
#define RAYSCENES_HEADER_ALREADY_DONE



#include <deque>
#include <unordered_map>
#include <string>
#include <any>
#include <functional>
#include <tuple>
#include <variant>

/**
 * @brief Create a rayscenemanager
 * 
 */
#define create_rsm() rayscenes::rayscenemanager rsm;
/**
 * @brief Create a rayscenemanager with a custom variable name
 * 
 */
#define create_rsm_with_name(name) rayscenes::rayscenemanager name;

/**
 * @brief Creates a rayscene and registers it
 * 
 */
#define register_rayscene(funcName, sceneName, ...) \
auto funcName = [](rayscenes::rayscenemanager &rsm, bool isTop) { \
  __VA_ARGS__ \
}; \
rsm.addScene(sceneName, funcName);
/**
 * @brief Creates a rayscene and registers it with a custom scene manager
 * 
 */
#define register_rayscene_custom_manager(sceneManager, funcName, sceneName, ...) \
auto funcName = [](rayscenes::rayscenemanager &rsm, bool isTop) { \
  __VA_ARGS__ \
}; \
sceneManager.addScene(sceneName, funcName);
/**
 * @brief Sets the active scene
 * 
 */
#define set_active_scene(sceneName) rsm.setActiveScene(sceneName);
/**
 * @brief Sets the active scene with a custom scene manager
 * 
 */
#define set_active_scene_custom_manager(sceneManager, sceneName) sceneManager.setActiveScene(sceneName);
/**
 * @brief Runs all active scenes
 * 
 */
#define run_active_scenes() rsm.renderActiveScenes();
/**
 * @brief Runs all active scenes with a custom scene manager
 * 
 */
#define run_active_scenes_custom_manager(sceneManager) sceneManager.renderActiveScenes();


/**
 * @brief RayScenes namespace
 * 
 */
namespace rayscenes {

	/**
	 * @brief RaySceneManager class, manages rayscenes
	 * 
	 */
	class rayscenemanager {
	public:

		/**
		 * @brief Type for the function for a rayscene, expands to `void (*)(rayscenes::rayscenemanager&, bool)`
		 * 
		 */
		using rayscenefunc = std::variant<void(*)(rayscenes::rayscenemanager&, bool), std::function<void(rayscenes::rayscenemanager&, bool)>>;

		/**
		 * @brief RayScene class, manages a single scene, it is mostly an abstraction for the scene functions
		 * 
		 */
        class rayscene {
        public:
			/**
			 * @brief Construct a new rayscene object
			 * 
			 * @param _func The function to call when the scene is active and should be rendered
			 */
            rayscene(rayscenefunc _func);

			/**
			 * @brief Construct a new rayscene object
			 * 
			 */
            rayscene();


			/**
			 * @brief Set/replace the function
			 * 
			 * @param _func The function to call when the scene is active and should be rendered
			 */
            void setFunc(rayscenefunc _func);

			/**
			 * @brief 
			 * 
			 * @param rsm The current rayscenemanager
			 * @param isTop If the scene is the top scene(the last one to be rendered)
			 */
            void call(rayscenemanager &rsm, bool isTop);

        private:
			/**
			 * @brief If the function has been set, prevents calling a null function
			 * 
			 */
            bool funcSet;

			/**
			 * @brief The function that will be called when the scene is active and should be rendered
			 * 
			 */
            rayscenefunc func;
        };

		/**
		 * @brief Construct a new rayscenemanager object
		 * 
		 */
		rayscenemanager();

		/**
		 * @brief Construct a new rayscenemanager object
		 * 
		 * @param r An old rayscenemanager to copy
		 */
		rayscenemanager(const rayscenemanager& r);


		/**
		 * @brief Get the map containing the scenes
		 * 
		 * @return std::unordered_map<std::string, rayscene>& Reference to map containing the scenes
		 */
		std::unordered_map<std::string, rayscene>& getAllScenes();

		/**
		 * @brief Replaces the map of scenes with a new one
		 * 
		 * @param newScenes The new map of scenes
		 */
		void setAllScenes(std::unordered_map<std::string, rayscene> newScenes);

		/**
		 * @brief Get a scene's object by id
		 * 
		 * @param id Id of the scene you want
		 * @return rayscene& Reference to the scene
		 */
		rayscene& getScene(std::string id);

		/**
		 * @brief Add a scene to the map
		 * 
		 * @param id The target id
		 * @param scene The scene to link the id to
		 */
		void addScene(std::string id, rayscene scene);

		/**
		 * @brief Add a scene to the map given a function not a scene
		 * 
		 * @param id The target id
		 * @param func The func to link the id to
		 */
		void addScene(std::string id, void (*func)(rayscenes::rayscenemanager&, bool) );
		void addScene(std::string id, std::function<void(rayscenes::rayscenemanager&, bool)>& func);

		/**
		 * @brief Remove a scene from the map by id
		 * 
		 * @param id The target id
		 */
		void removeScene(std::string id);


		/**
		 * @brief Get a deque of scene ids representing the active scenes
		 * 
		 * @return std::deque<std::string>& Reference to the deque
		 */
		std::deque<std::string>& getActiveScenes();

		/**
		 * @brief Set the current active scenes
		 * 
		 * @param ids A deque of ids to set as active
		 */
		void setActiveScenes(std::deque<std::string> ids);

		/**
		 * @brief Disables all scenes sets a new one as active
		 * 
		 * @param id The target id
		 */
		void setActiveScene(std::string id);

		/**
		 * @brief Adds a new scene on top of the others
		 * 
		 * @param id The target id
		 */
		void addActiveScene(std::string id);

		/**
		 * @brief Adds scenes on top of the others given a deque of ids
		 * 
		 * @param ids A deque of ids to set as active
		 */
		void addActiveScenes(std::deque<std::string> ids);


		/**
		 * @brief Remove a scene from the active scenes list
		 * 
		 * @param id The target id
		 */
		void removeActiveScene(std::string id);

		/**
		 * @brief Remove scenes from the active scenes list given a deque of ids
		 * 
		 * @param ids A deque of ids to set as active
		 */
		void removeActiveScenes(std::deque<std::string> ids);

		/**
		 * @brief Clears all scenes from the list, effectively stopping rendering. It is recommended you always have one scene active or some other update loop to ensure the program stays working.
		 * 
		 * @param id The target id
		 */
		void clearActiveScenes(std::string id);


		/**
		 * @brief Renders all scenes that are active, it is safe to modify the list during this running as it first creates a copy on the deque before beginning rendering.
		 * 
		 */
		void renderActiveScenes();

	private:
		/**
		 * @brief The map of all scenes
		 * 
		 */
		std::unordered_map<std::string, rayscene> scenes;

		/**
		 * @brief The map of currently active scenes
		 * 
		 */
		std::deque<std::string> activeScenes;

		/**
		 * @brief Clears a deque
		 * 
		 * @tparam T The type the deque stores, in general it is able to be deduced by the compiler
		 * @param q The deque to clear
		 */
		template<typename T>
		void clear_deque( std::deque<T> &q );
	
		/**
		 * @brief Clears a map of entries
		 * 
		 * @tparam K The type used for the key, in general it is able to be deduced by the compiler
		 * @tparam V The type used for the value, in general it is able to be deduced by the compiler
		 * @param q The map to clear
		 */
		template<typename K, typename V>
		void clear_unordered_map( std::unordered_map<K, V> &q );
	};

}

#endif

#ifdef RAYSCENES_IMPLEMENTATION
#ifndef RAYSCENES_IMPLEMENTATION_ALREADY_DONE
#define RAYSCENES_IMPLEMENTATION_ALREADY_DONE

#include "rayscenes.hpp"

#include <deque>
#include <unordered_map>
#include <string>
#include <any>
#include <functional>
#include <tuple>
#include <optional>
#include <typeinfo>

namespace rayscenes {
	namespace {
		template <class... Args>
		auto any_to_variant_cast(std::any a) -> std::variant<Args...>
		{
			if (!a.has_value())
				throw std::bad_any_cast();

			std::optional<std::variant<Args...>> v = std::nullopt;

			bool found = ((a.type() == typeid(Args) && (v = std::any_cast<Args>(std::move(a)), true)) || ...);

			if (!found)
				throw std::bad_any_cast{};

			return std::move(*v);
		}
	}

	// 
	// Class | rayscenemanager::rayscene 
	//
		//
		// Initializers
		//
		rayscenemanager::rayscene::rayscene(rayscenefunc _func) { func = _func; funcSet = true; }
		rayscenemanager::rayscene::rayscene() {};

		//
		// Utilities
		//
		void rayscenemanager::rayscene::setFunc(rayscenefunc _func) { func = _func; funcSet = true; }
		void rayscenemanager::rayscene::call(rayscenemanager &rsm, bool isTop) { 
			if (funcSet) 
				switch (func.index()) {
					case 0:
						std::get<void(*)(rayscenes::rayscenemanager&, bool)>(func)(rsm, isTop);
						break;
					case 1:
						std::get<std::function<void(rayscenes::rayscenemanager&, bool)>>(func)(rsm, isTop);
						break;
				}
		}


	//
	// Class | rayscenemanager
	//

		//
		// Initializers
		//
		rayscenemanager::rayscenemanager() {}
		rayscenemanager::rayscenemanager(const rayscenemanager& r) {
			clear_unordered_map(scenes);
			clear_deque(activeScenes);

			for (auto &[key, scene] : ((rayscenemanager)r).getAllScenes()) scenes[key] = scene;
			for (auto &scene : ((rayscenemanager)r).getActiveScenes()) activeScenes.push_back(scene);
		}

		//
		// Basic scene management
		//
		std::unordered_map<std::string, rayscenemanager::rayscene>& rayscenemanager::getAllScenes() { return scenes; }
		void                                                        rayscenemanager::setAllScenes(std::unordered_map<std::string, rayscene> newScenes) { for (auto &[key, scene] : newScenes) scenes[key] = scene; }
		rayscenemanager::rayscene&                                  rayscenemanager::getScene(std::string id) { return scenes[id]; }
		void                                                        rayscenemanager::addScene(std::string id, rayscene scene) { scenes[id] = scene; }
		void                                                        rayscenemanager::addScene(std::string id, void (*func)(rayscenes::rayscenemanager&, bool)) { scenes[id] = rayscene( rayscenefunc(func) );}
		void                                                        rayscenemanager::addScene(std::string id, std::function<void(rayscenes::rayscenemanager&, bool)>& func) { scenes[id] = rayscene( rayscenefunc(func) );}
		void                                                        rayscenemanager::removeScene(std::string id) { scenes.erase(id); }

		//
		// Active scene management
		//
		std::deque<std::string>& rayscenemanager::getActiveScenes() { return activeScenes; }
		void                     rayscenemanager::setActiveScenes(std::deque<std::string> ids) {
			clear_deque(activeScenes);
			for (auto &id : ids) activeScenes.push_back(id);
		}
		void                     rayscenemanager::setActiveScene(std::string id) {
			clear_deque(activeScenes);
			activeScenes.push_back(id);
		}
		void                     rayscenemanager::addActiveScene(std::string id) { activeScenes.push_back(id); }
		void                     rayscenemanager::addActiveScenes(std::deque<std::string> ids) { for (auto &id : ids) activeScenes.push_back(id); }
		void                     rayscenemanager::removeActiveScene(std::string id) { activeScenes.erase(std::remove(activeScenes.begin(), activeScenes.end(), id), activeScenes.end()); }
		void                     rayscenemanager::removeActiveScenes(std::deque<std::string> ids) { for (auto &id : ids) activeScenes.erase(std::remove(activeScenes.begin(), activeScenes.end(), id), activeScenes.end()); }
		void                     rayscenemanager::clearActiveScenes(std::string id) { activeScenes.erase(std::remove(activeScenes.begin(), activeScenes.end(), id), activeScenes.end()); }

		//
		// Other functions
		//
		void rayscenemanager::renderActiveScenes() {
			std::deque<std::string> temp(activeScenes);
			for (auto &i : temp) 
				if (scenes.find(i) != scenes.end())
					scenes[i].call(*this, activeScenes.back() == i);
		}

		//
		// Private utility functions
		//
		template<typename T>
		void rayscenemanager::clear_deque(std::deque<T> &q) {
			std::deque<T> empty;
			std::swap(q, empty);
		}
		template<typename K, typename V>
		void rayscenemanager::clear_unordered_map(std::unordered_map<K, V> &q) {
			std::unordered_map<K, V> empty;
			std::swap(q, empty);
		}
}

#endif
#endif
